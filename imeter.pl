#!/usr/bin/perl
# Copyright (C) 2007-2014 Ian Korf, Gen√≠s Parra, and Keith Brandam
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

use strict; use warnings;
use FAlite;
use Getopt::Std;
use vars qw($opt_w $opt_s $opt_r $opt_g $opt_d $opt_a $opt_c $opt_f $opt_o $opt_m $opt_p);

################################
#
#   S e t u p
#
################################

# set up some default values
my $window_step = 1;
my $window_size = 8;
my $donor = 5;
my $acceptor = 10;
my $cutoff      =  1.2;
my $gap         = 3; # how far can two peaks be apart to still be considered one peak?
my $gff         = 0; 
my $weighting_factor = 300;
my $VERSION = "2.1";

getopts('w:s:d:c:a:f:g:rom:p:');
$window_size      = $opt_w if $opt_w;
$window_step      = $opt_s if $opt_s;
$donor            = $opt_d if $opt_d;
$acceptor         = $opt_a if $opt_a;
$cutoff           = $opt_c if $opt_c;
$gap              = $opt_g if $opt_g;
$weighting_factor = $opt_f if $opt_f;

$gff = 1 if $opt_o;

die "
Note: Calculates IMEter v$VERSION scores, using default parameters from 
Phytozome v9.0 Arabidopsis thalian introns (can be changed with -m option).

usage: imeter.pl [options] -m <parameter file> <fasta file> 

options:
  -w <int>     window size nt [default $window_size]
  -s <int>     step size nt [default $window_step]
  -d <int>     donor sequence to clip [default $donor]
  -a <int>     acceptor sequence to clip [default $acceptor]
  -g <int>     minimum gap allowed between high scoring windows [default $gap]
  -c <float>   threshold value to decide what is a high scoring window [default $cutoff]
  -f <int>     weighting factor to penalize peaks that are further away [default $weighting_factor]
  -r           calculate score for reverse strand
  -p           A file of IMEter scores at each percentile (to include in output)
  -o           print GFF info of each peak

Parameter files can be generated by using the IME_trainer.pl script. Percentile file
information can be generated by using the ime_distance_info.pl script. Note that default 
output takes the form of:

<sequence identifier>\t<version 1 IMEter score>\t<version $VERSION IMEter score>

If a percentile file is specified, the output will also include a percentile value for the
IMEter score of the intron being tested. E.g. a score of X ranks in the Yth Percentile
of all intron scores for species Z.

" unless @ARGV == 1;

die "Window size (-w) must be at least 5\n" if ($window_size < 5);
die "Window step (-s) must be <= window size (-w)\n" if ($window_step > $window_size);

my ($FASTA) = @ARGV;


############################################################################
#
#  Read parameter and percentile files if specified
#
############################################################################

my ($model, $wordsize) = read_imeter_parameter_file($opt_m);

my %percentiles;
read_imeter_percentile_file($opt_p) if ($opt_p);
	

################################
#
#   M a i n   L o o p
#
################################

# check for standard input otherwise open regular filehandle
my ($fasta, $input);

if ($FASTA eq '-') {
	$fasta = new FAlite(\*STDIN);
} else {
    open($input,"<", $FASTA) or die "Can't open $FASTA\n";
    $fasta = new FAlite(\*$input);
}

while (my $entry = $fasta->nextEntry) {
	my ($id) = $entry->def =~ /^>(\S+)/;
	my $seq = uc $entry->seq;
	
	# clip sequence to remove donor and acceptor?
	$seq = substr($seq, $donor, -$acceptor);

	my $imeter_v1_score = 0;
	my $imeter_v2_score = 0;

	# loop over input sequence in windows of size k, and score each kmer
	# This is all we need to do to calculate IMEter v1 and v3 scores.

	my @records;
	
	for (my $i = 0; $i <= length($seq) - $wordsize; $i++){
	    my $subseq = substr($seq, $i, $wordsize);
		# are we working on reverse strand?
		$subseq = reverse_complement(substr($seq, $i, 5)) if ($opt_r);
		$records[$i]{start}  = $i;
	   	$records[$i]{end}    = $i + $wordsize -1;

		# it's possible that input sequence has ambiguity codes, in which case we can't 
		# calculate a pentamer score, so just set to 0.
		if(defined $model->{$subseq}){
		   	$records[$i]{score}  = $model->{$subseq};			
		} else{
		   	$records[$i]{score}  = 0;
		}
		$imeter_v1_score += $records[$i]{score};
	}					

	# now we want to make a list of the windows whose score exceeds the $cutoff value
	my @windows = ();
	my $high_scoring_window_count = 0;
	
	for (my $i = 0; $i < @records - $window_size + $wordsize; $i += $window_step){

		my ($start, $end) = ($i, $i + $window_size - 1); 
		my $window_score = 0;
		
		# now loop through all pentamers that comprise the window and add their score to $window_score
	  	for (my $j = $start; $j + $wordsize -1 <= $end; $j++){
		 	$window_score +=  $records[$j]{score};
		}

		# if window score is above cutoff, store details...but store average score per base
 		if ($window_score >= $cutoff) {
       		my $avg_score = $window_score/$window_size;
    		$windows[$high_scoring_window_count]{start}     = $i;
    		$windows[$high_scoring_window_count]{end}       = $i + $window_size - 1;
    		$windows[$high_scoring_window_count]{avg_score} = $avg_score;
    		$high_scoring_window_count++;		    
 		} 
	}
	
	################################
	#
	#   F i n d   P e a k s 
	#
	################################

   	my @peak; 
   	my $peak_counter = 0;

    # Genis automatically defines first peak as equal to the first high scoring window. Why?
   	$peak[0]{start}     = $windows[0]{start};
   	$peak[0]{end}       = $windows[0]{end};
   	$peak[0]{avg_score} = $windows[0]{avg_score};

	# loop through remaining high scoring windows  I.e. start at $i = 1 rather than 0
   	for (my $i = 1; $i < @windows; $i++ ){

		# now ask whether current window is within $gap nt of current peak
    	if ($windows[$i]{start} - $peak[$peak_counter]{end} < $gap){

			# if window overlaps peak, then change end coordinate of current peak...
        	$peak[$peak_counter]{end} = $windows[$i]{end};

			# also change the score of the peak by making a new average score
    	 	$peak[$peak_counter]{avg_score} = (($peak[$peak_counter]{avg_score} + $windows[$i]{avg_score}) / 2);

      	} else {
			# at this point you have defined one peak and can start looking for the next one
			# increment peak counter and set default values of 2nd peak to be that of current window (???)
        	$peak_counter++;
	 		$peak[$peak_counter]{start}     = $windows[$i]{start};
	 		$peak[$peak_counter]{end}       = $windows[$i]{end};
	 		$peak[$peak_counter]{avg_score} = $windows[$i]{avg_score};
      	}
	}

	################################
	#
	#   S c o r e   P e a k s 
	#
	################################
	

    for (my $i = 0; $i <= $peak_counter; $i++ ){  		
    	my $peak_score = 0;
		
		# just skip forward if there were no peaks detected
		next if not defined($peak[$i]{start});

	 	for (my $j = $peak[$i]{start}; $j <= $peak[$i]{end} - $wordsize +1; $j++){
			$peak_score +=  $records[$j]{score};
       	}

		# calculate a weighted score based on distance of peak
		# include a donor offset in case a large amount of sequence was clipped
        my $weighted_score = $peak_score * exp(-($peak[$i]{start}+$donor) * 1/$weighting_factor); 
	    printf("%s\tIMEter\tpeak\t%d\t%d\t%.2f\t+\t.\t.\n", $id, $peak[$i]{start}, $peak[$i]{end}, $weighted_score) if ($gff);	     
	    $imeter_v2_score += $weighted_score;
	}
	
	# with large window sizes can end up in situations where individually positive scoring
	# windows can be connected by short regions of negative score. Can end up producing a single
	# large negative peak. So should always set to zero if this happens.
	$imeter_v2_score = 0 if ($imeter_v2_score < 0);

	# now check what percentile this score corresponds to
	my $v2_percentile;
	if($opt_p){
		# loop over scores at each percentile (high to low)
		foreach my $score (sort {$b <=> $a} keys %percentiles){
			if ($imeter_v2_score >= $score){
				$v2_percentile = $percentiles{$score};
				last;
			}
		}
	}
	# print out final scores
	my $formatted_v1_score = sprintf("%.2f",$imeter_v1_score);
	my $formatted_v2_score = sprintf("%.2f",$imeter_v2_score);

	my $final_output = "$id\t$formatted_v1_score\t$formatted_v2_score";
	if ($opt_p){
		$final_output .= "\t$v2_percentile";
	} 
	print "$final_output\n" unless ($gff);
}

close $input if ($FASTA ne '-');

exit(0);

############################ 
#
#   S U B R O U T I N E S 
#
#############################


sub reverse_complement {
        my ($seq) = @_;
        $seq = reverse $seq;
        $seq =~ tr[ACGTRYMKBDHVacgtrymkdbhv]
                  [TGCAYRKMVHDBtgcayrkmvhdb];
        return $seq;
}


sub read_imeter_parameter_file {
	my ($file) = @_;

	my %model;
	my $wordsize;
	open(IN, $file) or die;
	while (<IN>) {
		next if (/^#/);
		my ($word, $score) = split;
		$word = uc $word;
		$model{$word} = $score;
		$wordsize = length($word) unless defined $wordsize;
	}
	close IN;	
	return (\%model, $wordsize);	
}


sub read_imeter_percentile_file {
	my ($file) = @_;
	open(IN, $file) or die;
	while (<IN>) {
		next if (/^#/);
		my ($percentile, $score) = split;
		$percentiles{$score} = $percentile;
	}
	close IN;	
}


exit(0); 
